{"ast":null,"code":"/**\n * This module offers the internal \"keypress\" functionality from node-core's\n * `readline` module, for your own programs and modules to use.\n *\n * Usage:\n *\n *   require('keypress')(process.stdin);\n *\n *   process.stdin.on('keypress', function (ch, key) {\n *     console.log(ch, key);\n *     if (key.ctrl && key.name == 'c') {\n *       process.stdin.pause();\n *     }\n *   });\n *   proces.stdin.resume();\n */\nvar exports = module.exports = keypress;\n\nexports.enableMouse = function (stream) {\n  stream.write('\\x1b' + '[?1000h');\n};\n\nexports.disableMouse = function (stream) {\n  stream.write('\\x1b' + '[?1000l');\n};\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\n\nfunction keypress(stream) {\n  if (isEmittingKeypress(stream)) return;\n  stream._emitKeypress = true;\n\n  function onData(b) {\n    if (stream.listeners('keypress').length > 0) {\n      emitKey(stream, b);\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener('data', onData);\n      stream.on('newListener', onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event == 'keypress') {\n      stream.on('data', onData);\n      stream.removeListener('newListener', onNewListener);\n    }\n  }\n\n  if (stream.listeners('keypress').length > 0) {\n    stream.on('data', onData);\n  } else {\n    stream.on('newListener', onNewListener);\n  }\n}\n/**\n * Returns `true` if the stream is already emitting \"keypress\" events.\n * `false` otherwise.\n */\n\n\nfunction isEmittingKeypress(stream) {\n  var rtn = stream._emitKeypress;\n\n  if (!rtn) {\n    // hack: check for the v0.6.x \"data\" event\n    stream.listeners('data').forEach(function (l) {\n      if (l.name == 'onData' && /emitKey/.test(l.toString())) {\n        rtn = true;\n        stream._emitKeypress = true;\n      }\n    });\n  }\n\n  if (!rtn) {\n    // hack: check for the v0.6.x \"newListener\" event\n    stream.listeners('newListener').forEach(function (l) {\n      if (l.name == 'onNewListener' && /keypress/.test(l.toString())) {\n        rtn = true;\n        stream._emitKeypress = true;\n      }\n    });\n  }\n\n  return rtn;\n}\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\n// Regexes used for ansi escape code splitting\n\n\nvar metaKeyCodeRe = /^(?:\\x1b)([a-zA-Z0-9])$/;\nvar functionKeyCodeRe = /^(?:\\x1b+)(O|N|\\[|\\[\\[)(?:(\\d+)(?:;(\\d+))?([~^$])|(?:1;)?(\\d+)?([a-zA-Z]))/;\n\nfunction emitKey(stream, s) {\n  var ch,\n      key = {\n    name: undefined,\n    ctrl: false,\n    meta: false,\n    shift: false\n  },\n      parts;\n\n  if (Buffer.isBuffer(s)) {\n    if (s[0] > 127 && s[1] === undefined) {\n      s[0] -= 128;\n      s = '\\x1b' + s.toString(stream.encoding || 'utf-8');\n    } else {\n      s = s.toString(stream.encoding || 'utf-8');\n    }\n  }\n\n  key.sequence = s;\n\n  if (s === '\\r' || s === '\\n') {\n    // enter\n    key.name = 'enter';\n  } else if (s === '\\t') {\n    // tab\n    key.name = 'tab';\n  } else if (s === '\\b' || s === '\\x7f' || s === '\\x1b\\x7f' || s === '\\x1b\\b') {\n    // backspace or ctrl+h\n    key.name = 'backspace';\n    key.meta = s.charAt(0) === '\\x1b';\n  } else if (s === '\\x1b' || s === '\\x1b\\x1b') {\n    // escape key\n    key.name = 'escape';\n    key.meta = s.length === 2;\n  } else if (s === ' ' || s === '\\x1b ') {\n    key.name = 'space';\n    key.meta = s.length === 2;\n  } else if (s <= '\\x1a') {\n    // ctrl+letter\n    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\n    key.ctrl = true;\n  } else if (s.length === 1 && s >= 'a' && s <= 'z') {\n    // lowercase letter\n    key.name = s;\n  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {\n    // shift+letter\n    key.name = s.toLowerCase();\n    key.shift = true;\n  } else if (parts = metaKeyCodeRe.exec(s)) {\n    // meta+character key\n    key.name = parts[1].toLowerCase();\n    key.meta = true;\n    key.shift = /^[A-Z]$/.test(parts[1]);\n  } else if (parts = functionKeyCodeRe.exec(s)) {\n    // ansi escape sequence\n    // reassemble the key code leaving out leading \\x1b's,\n    // the modifier key bitflag and any meaningless \"1;\" sequence\n    var code = (parts[1] || '') + (parts[2] || '') + (parts[4] || '') + (parts[6] || ''),\n        modifier = (parts[3] || parts[5] || 1) - 1; // Parse the key modifier\n\n    key.ctrl = !!(modifier & 4);\n    key.meta = !!(modifier & 10);\n    key.shift = !!(modifier & 1);\n    key.code = code; // Parse the key itself\n\n    switch (code) {\n      /* xterm/gnome ESC O letter */\n      case 'OP':\n        key.name = 'f1';\n        break;\n\n      case 'OQ':\n        key.name = 'f2';\n        break;\n\n      case 'OR':\n        key.name = 'f3';\n        break;\n\n      case 'OS':\n        key.name = 'f4';\n        break;\n\n      /* xterm/rxvt ESC [ number ~ */\n\n      case '[11~':\n        key.name = 'f1';\n        break;\n\n      case '[12~':\n        key.name = 'f2';\n        break;\n\n      case '[13~':\n        key.name = 'f3';\n        break;\n\n      case '[14~':\n        key.name = 'f4';\n        break;\n\n      /* from Cygwin and used in libuv */\n\n      case '[[A':\n        key.name = 'f1';\n        break;\n\n      case '[[B':\n        key.name = 'f2';\n        break;\n\n      case '[[C':\n        key.name = 'f3';\n        break;\n\n      case '[[D':\n        key.name = 'f4';\n        break;\n\n      case '[[E':\n        key.name = 'f5';\n        break;\n\n      /* common */\n\n      case '[15~':\n        key.name = 'f5';\n        break;\n\n      case '[17~':\n        key.name = 'f6';\n        break;\n\n      case '[18~':\n        key.name = 'f7';\n        break;\n\n      case '[19~':\n        key.name = 'f8';\n        break;\n\n      case '[20~':\n        key.name = 'f9';\n        break;\n\n      case '[21~':\n        key.name = 'f10';\n        break;\n\n      case '[23~':\n        key.name = 'f11';\n        break;\n\n      case '[24~':\n        key.name = 'f12';\n        break;\n\n      /* xterm ESC [ letter */\n\n      case '[A':\n        key.name = 'up';\n        break;\n\n      case '[B':\n        key.name = 'down';\n        break;\n\n      case '[C':\n        key.name = 'right';\n        break;\n\n      case '[D':\n        key.name = 'left';\n        break;\n\n      case '[E':\n        key.name = 'clear';\n        break;\n\n      case '[F':\n        key.name = 'end';\n        break;\n\n      case '[H':\n        key.name = 'home';\n        break;\n\n      /* xterm/gnome ESC O letter */\n\n      case 'OA':\n        key.name = 'up';\n        break;\n\n      case 'OB':\n        key.name = 'down';\n        break;\n\n      case 'OC':\n        key.name = 'right';\n        break;\n\n      case 'OD':\n        key.name = 'left';\n        break;\n\n      case 'OE':\n        key.name = 'clear';\n        break;\n\n      case 'OF':\n        key.name = 'end';\n        break;\n\n      case 'OH':\n        key.name = 'home';\n        break;\n\n      /* xterm/rxvt ESC [ number ~ */\n\n      case '[1~':\n        key.name = 'home';\n        break;\n\n      case '[2~':\n        key.name = 'insert';\n        break;\n\n      case '[3~':\n        key.name = 'delete';\n        break;\n\n      case '[4~':\n        key.name = 'end';\n        break;\n\n      case '[5~':\n        key.name = 'pageup';\n        break;\n\n      case '[6~':\n        key.name = 'pagedown';\n        break;\n\n      /* putty */\n\n      case '[[5~':\n        key.name = 'pageup';\n        break;\n\n      case '[[6~':\n        key.name = 'pagedown';\n        break;\n\n      /* rxvt */\n\n      case '[7~':\n        key.name = 'home';\n        break;\n\n      case '[8~':\n        key.name = 'end';\n        break;\n\n      /* rxvt keys with modifiers */\n\n      case '[a':\n        key.name = 'up';\n        key.shift = true;\n        break;\n\n      case '[b':\n        key.name = 'down';\n        key.shift = true;\n        break;\n\n      case '[c':\n        key.name = 'right';\n        key.shift = true;\n        break;\n\n      case '[d':\n        key.name = 'left';\n        key.shift = true;\n        break;\n\n      case '[e':\n        key.name = 'clear';\n        key.shift = true;\n        break;\n\n      case '[2$':\n        key.name = 'insert';\n        key.shift = true;\n        break;\n\n      case '[3$':\n        key.name = 'delete';\n        key.shift = true;\n        break;\n\n      case '[5$':\n        key.name = 'pageup';\n        key.shift = true;\n        break;\n\n      case '[6$':\n        key.name = 'pagedown';\n        key.shift = true;\n        break;\n\n      case '[7$':\n        key.name = 'home';\n        key.shift = true;\n        break;\n\n      case '[8$':\n        key.name = 'end';\n        key.shift = true;\n        break;\n\n      case 'Oa':\n        key.name = 'up';\n        key.ctrl = true;\n        break;\n\n      case 'Ob':\n        key.name = 'down';\n        key.ctrl = true;\n        break;\n\n      case 'Oc':\n        key.name = 'right';\n        key.ctrl = true;\n        break;\n\n      case 'Od':\n        key.name = 'left';\n        key.ctrl = true;\n        break;\n\n      case 'Oe':\n        key.name = 'clear';\n        key.ctrl = true;\n        break;\n\n      case '[2^':\n        key.name = 'insert';\n        key.ctrl = true;\n        break;\n\n      case '[3^':\n        key.name = 'delete';\n        key.ctrl = true;\n        break;\n\n      case '[5^':\n        key.name = 'pageup';\n        key.ctrl = true;\n        break;\n\n      case '[6^':\n        key.name = 'pagedown';\n        key.ctrl = true;\n        break;\n\n      case '[7^':\n        key.name = 'home';\n        key.ctrl = true;\n        break;\n\n      case '[8^':\n        key.name = 'end';\n        key.ctrl = true;\n        break;\n\n      /* misc. */\n\n      case '[Z':\n        key.name = 'tab';\n        key.shift = true;\n        break;\n\n      default:\n        key.name = 'undefined';\n        break;\n    }\n  } else if (s.length > 1 && s[0] !== '\\x1b') {\n    // Got a longer-than-one string of characters.\n    // Probably a paste, since it wasn't a control sequence.\n    Array.prototype.forEach.call(s, function (c) {\n      emitKey(stream, c);\n    });\n    return;\n  }\n\n  if (key.code == '[M') {\n    key.name = 'mouse';\n    var s = key.sequence;\n    var b = s.charCodeAt(3);\n    key.x = s.charCodeAt(4) - 040;\n    key.y = s.charCodeAt(5) - 040;\n    key.scroll = 0;\n    key.ctrl = !!(1 << 4 & b);\n    key.meta = !!(1 << 3 & b);\n    key.shift = !!(1 << 2 & b);\n    key.release = (3 & b) === 3;\n\n    if (1 << 6 & b) {\n      //scroll\n      key.scroll = 1 & b ? 1 : -1;\n    }\n\n    if (!key.release && !key.scroll) {\n      key.button = b & 3;\n    }\n  } // Don't emit a key if no name was found\n\n\n  if (key.name === undefined) {\n    key = undefined;\n  }\n\n  if (s.length === 1) {\n    ch = s;\n  }\n\n  if (key && key.name == 'mouse') {\n    stream.emit('mousepress', key);\n  } else if (key || ch) {\n    stream.emit('keypress', ch, key);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}